import typing as t
from collections.abc import Buffer

class Viewport2D:
    def __init__(self,
                 left: float,
                 right: float,
                 bottom: float,
                 top: float) -> None:
        self.left = left
        self.right = right
        self.bottom = bottom
        self.top = top

    def to_viewport_3d(self) -> Viewport3D: ...

class Viewport3D:
    def __init__(self,
                 left: float,
                 right: float,
                 bottom: float,
                 top: float,
                 near: float,
                 far: float) -> None:
        self.left = left
        self.right = right
        self.bottom = bottom
        self.top = top
        self.near = near
        self.far = far

    def to_viewport_2d(self) -> Viewport2D: ...

class VectorIter:
    def __iter__(self) -> t.Self: ...
    def __next__(self) -> float: ...

class Vector2:
    x: float
    y: float

    @classmethod
    def one(cls) -> t.Self: ...

    @classmethod
    def zero(cls) -> t.Self: ...

    @classmethod
    def unit_x(cls) -> t.Self: ...

    @classmethod
    def unit_y(cls) -> t.Self: ...

    @t.overload
    def __init__(self, value: t.SupportsFloat, /) -> None: ...

    @t.overload
    def __init__(self, values: Buffer, /) -> None: ...

    @t.overload
    def __init__(self, values: t.Sequence[float], /) -> None: ...

    @t.overload
    def __init__(self, v0: t.SupportsFloat, v1: t.SupportsFloat, /) -> None: ...

    def length(self) -> float: ...
    def length_squared(self) -> float: ...
    def cross(self, other: t.Self, /) -> float: ...
    def dot(self, other: t.Self, /) -> float: ...
    def distance(self, other: t.Self, /) -> float: ...
    def distance_squared(self, other: t.Self) -> float: ...
    def normalize(self) -> None: ...
    def normalized(self) -> t.Self: ...
    def interpolate(self, other: t.Self, amount: float, /) -> t.Self: ...

    def __iter__(self) -> VectorIter: ...

    def __buffer__(self, flags: int) -> memoryview: ...

    def __len__(self) -> int: ...
    def __setitem__(self, index: int, value: t.SupportsFloat) -> None: ...
    def __getitem__(self, index: int) -> float: ...

    def __add__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __iadd__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __sub__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __isub__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __mul__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __imul__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __truediv__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __itruediv__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __mod__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __imod__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __neg__(self) -> t.Self: ...

class Vector3:
    x: float
    y: float
    z: float

    @classmethod
    def one(cls) -> t.Self: ...

    @classmethod
    def zero(cls) -> t.Self: ...

    @classmethod
    def unit_x(cls) -> t.Self: ...

    @classmethod
    def unit_y(cls) -> t.Self: ...

    @classmethod
    def unit_z(cls) -> t.Self: ...

    @t.overload
    def __init__(self, value: t.SupportsFloat, /) -> None: ...

    @t.overload
    def __init__(self, values: Buffer, /) -> None: ...

    @t.overload
    def __init__(self, values: t.Sequence[float], /) -> None: ...

    @t.overload
    def __init__(self, v0: t.SupportsFloat, v1: t.SupportsFloat, v2: t.SupportsFloat, /) -> None: ...

    def length(self) -> float: ...
    def length_squared(self) -> float: ...
    def cross(self, other: t.Self, /) -> t.Self: ...
    def dot(self, other: t.Self, /) -> float: ...
    def angle(self, other: t.Self, /) -> float: ...
    def distance(self, other: t.Self, /) -> float: ...
    def distance_squared(self, other: t.Self) -> float: ...
    def normalize(self) -> None: ...
    def normalized(self) -> t.Self: ...
    def interpolate(self, other: t.Self, amount: float, /) -> t.Self: ...

    def __iter__(self) -> VectorIter: ...

    def __buffer__(self, flags: int) -> memoryview: ...

    def __len__(self) -> int: ...
    def __setitem__(self, index: int, value: t.SupportsFloat) -> None: ...
    def __getitem__(self, index: int) -> float: ...

    def __add__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __iadd__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __sub__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __isub__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __mul__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __imul__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __truediv__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __itruediv__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __mod__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __imod__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __neg__(self) -> t.Self: ...

class Vector4:
    x: float
    y: float
    z: float
    w: float

    @classmethod
    def one(cls) -> t.Self: ...

    @classmethod
    def zero(cls) -> t.Self: ...

    @classmethod
    def unit_x(cls) -> t.Self: ...

    @classmethod
    def unit_y(cls) -> t.Self: ...

    @classmethod
    def unit_z(cls) -> t.Self: ...

    @classmethod
    def unit_w(cls) -> t.Self: ...

    @t.overload
    def __init__(self, value: t.SupportsFloat, /) -> None: ...

    @t.overload
    def __init__(self, values: Buffer, /) -> None: ...

    @t.overload
    def __init__(self, values: t.Sequence[float], /) -> None: ...

    @t.overload
    def __init__(self, v0: t.SupportsFloat, v1: t.SupportsFloat, v2: t.SupportsFloat, v3: t.SupportsFloat, /) -> None: ...

    def length(self) -> float: ...
    def length_squared(self) -> float: ...
    def dot(self, other: t.Self, /) -> float: ...
    def distance(self, other: t.Self, /) -> float: ...
    def distance_squared(self, other: t.Self) -> float: ...
    def normalize(self) -> None: ...
    def normalized(self) -> t.Self: ...
    def interpolate(self, other: t.Self, amount: float, /) -> t.Self: ...

    def __iter__(self) -> VectorIter: ...

    def __buffer__(self, flags: int) -> memoryview: ...

    def __len__(self) -> int: ...
    def __setitem__(self, index: int, value: t.SupportsFloat) -> None: ...
    def __getitem__(self, index: int) -> float: ...

    def __add__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __iadd__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __sub__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __isub__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __mul__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __imul__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __truediv__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __itruediv__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __mod__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __imod__(self, other: t.Self | t.SupportsFloat) -> t.Self: ...
    def __neg__(self) -> t.Self: ...

class Matrix2:
    @classmethod
    def identity(cls) -> t.Self: ...

    @classmethod
    def zero(cls) -> t.Self: ...

    @t.overload
    def __init__(self, values: Buffer, /) -> None: ...

    @t.overload
    def __init__(self, values: t.Sequence[t.SupportsFloat], /) -> None: ...

    @t.overload
    def __init__(self, row0: Vector2, row1: Vector2, /) -> None: ...

    def transpose(self) -> None: ...
    def transposed(self) -> t.Self: ...
    def inverse(self) -> None: ...
    def inversed(self) -> t.Self: ...
    def determinant(self) -> float: ...

    def __buffer__(self, flags: int) -> memoryview: ...

    def __len__(self) -> int: ...
    def __getitem__(self, index: int | tuple[int, int]) -> float: ...
    def __setitem__(self, index: int | tuple[int, int], value: t.SupportsFloat) -> None: ...

    def __add__(self, other: t.Self) -> t.Self: ...
    def __iadd__(self, other: t.Self) -> t.Self: ...
    def __sub__(self, other: t.Self) -> t.Self: ...
    def __isub__(self, other: t.Self) -> t.Self: ...
    def __mul__(self, other: t.Self) -> t.Self: ...
    def __imul__(self, other: t.Self) -> t.Self: ...
    def __matmul__(self, other: t.Self) -> t.Self: ...
    def __imatmul__(self, other: t.Self) -> t.Self: ...

class Matrix3:
    @classmethod
    def identity(cls) -> t.Self: ...

    @classmethod
    def zero(cls) -> t.Self: ...

    @t.overload
    def __init__(self, values: Buffer, /) -> None: ...

    @t.overload
    def __init__(self, values: t.Sequence[t.SupportsFloat], /) -> None: ...

    @t.overload
    def __init__(self, row0: Vector3, row1: Vector3, row2: Vector3, /) -> None: ...

    @t.overload
    def __init__(self, topleft: Matrix2, /) -> None: ... # type: ignore[overload-cannot-match]

    def transpose(self) -> None: ...
    def transposed(self) -> t.Self: ...
    def inverse(self) -> None: ...
    def inversed(self) -> t.Self: ...
    def determinant(self) -> float: ...

    def __buffer__(self, flags: int) -> memoryview: ...

    def __len__(self) -> int: ...
    def __getitem__(self, index: int | tuple[int, int]) -> float: ...
    def __setitem__(self, index: int | tuple[int, int], value: t.SupportsFloat) -> None: ...

    def __add__(self, other: t.Self) -> t.Self: ...
    def __iadd__(self, other: t.Self) -> t.Self: ...
    def __sub__(self, other: t.Self) -> t.Self: ...
    def __isub__(self, other: t.Self) -> t.Self: ...
    def __mul__(self, other: t.Self) -> t.Self: ...
    def __imul__(self, other: t.Self) -> t.Self: ...
    def __matmul__(self, other: t.Self) -> t.Self: ...
    def __imatmul__(self, other: t.Self) -> t.Self: ...

# TODO Allow passing quaternions as rotation values
# TODO Add ability to iterate over rows and columns as Vector4 objects
class Matrix4:
    @classmethod
    def identity(cls) -> t.Self: ...

    @classmethod
    def zero(cls) -> t.Self: ...

    @classmethod
    def transform(cls, translation: Vector3, scale: Vector3, rotation: Vector3, /) -> t.Self: ...

    @classmethod
    def ortho(cls, left: float, right: float, bottom: float, top: float, near: float, far: float, /) -> t.Self: ...

    @classmethod
    def perspective(cls, fov: float, aspect: float, near: float, far: float, /) -> t.Self: ...

    @classmethod
    def look_at(cls, eye: Vector3, center: Vector3, up: Vector3) -> t.Self: ...

    @t.overload
    def __init__(self, values: Buffer, /) -> None: ...

    @t.overload
    def __init__(self, values: t.Sequence[t.SupportsFloat], /) -> None: ...

    @t.overload
    def __init__(self, row0: Vector4, row1: Vector4, row2: Vector4, row3: Vector4, /) -> None: ...

    @t.overload
    def __init__(self, topleft: Matrix3, /) -> None: ... # type: ignore[overload-cannot-match]

    @t.overload
    def rotate(self, angle: float, axis: Vector3, /) -> None: ...

    @t.overload
    def rotate(self, rotation: Vector3, /) -> None: ...

    def translate(self, translation: Vector3, /) -> None: ...
    def scale(self, scale: Vector3, /) -> None: ...
    def perspective_resize(self, aspect: t.SupportsFloat, /) -> None: ...
    def transpose(self) -> None: ...
    def transposed(self) -> t.Self: ...
    def inverse(self) -> None: ...
    def inversed(self) -> t.Self: ...
    def inverse_fast(self) -> None: ...
    def inversed_fast(self) -> t.Self: ...
    def determinant(self) -> float: ...

    def __buffer__(self, flags: int, /) -> memoryview: ...

    def __len__(self) -> int: ...
    def __getitem__(self, index: int | tuple[int, int]) -> float: ...
    def __setitem__(self, index: int | tuple[int, int], value: t.SupportsFloat) -> None: ...

    def __add__(self, other: t.Self) -> t.Self: ...
    def __iadd__(self, other: t.Self) -> t.Self: ...
    def __sub__(self, other: t.Self) -> t.Self: ...
    def __isub__(self, other: t.Self) -> t.Self: ...
    def __mul__(self, other: t.Self) -> t.Self: ...
    def __imul__(self, other: t.Self) -> t.Self: ...
    def __matmul__(self, other: t.Self) -> t.Self: ...
    def __imatmul__(self, other: t.Self) -> t.Self: ...

def deg_to_rad(value: t.SupportsFloat) -> float: ...
def rad_to_deg(value: t.SupportsFloat) -> float: ...
